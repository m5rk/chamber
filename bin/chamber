#!/usr/bin/env ruby

require 'pp'
require 'thor'
require 'bundler'
require 'chamber'
require 'yaml'
require 'tempfile'

module  Chamber
module  Commands
  class Heroku < Thor
    class_option :app,
                 type:    :string,
                 aliases: '-a',
                 desc:    'The name of the Heroku application whose config values will be affected'

    desc 'clear', 'Removes all Heroku environment variables which match settings that Chamber knows about'
    method_option :dry_run,
                  type:     :boolean,
                  aliases:  '-d',
                  desc:     'Does not actually remove anything, but instead displays what would change if cleared'
    def clear
      ::Chamber::Commands::Chamber.init(options)

      keys = ::Chamber.to_environment.keys

      if options[:dry_run]
        puts "Running without --dry-run will remove the following Heroku environment variables"

        keys_regex            = keys.join('|')
        current_heroku_config = heroku("config --shell")

        current_heroku_config.each_line do |line|
          puts line if line.match(keys_regex)
        end
      else
        puts heroku("config:unset #{keys.join(' ')}")
      end
    end

    desc 'push', 'Sends settings to Heroku so that they may be used in the application once it is deployed'
    method_option :dry_run,
                  type:     :boolean,
                  aliases:  '-d',
                  desc:     'Does not actually push anything to Heroku, but instead displays what would change if pushed'
    method_option :only_ignored,
                  type:     :boolean,
                  aliases:  '-o',
                  default:  true,
                  desc:     'Does not push settings up to Heroku unless the file that the setting is contained in has been gitignored'
    def push
      ::Chamber::Commands::Chamber.init(options)

      if options[:only_ignored]
        ignored_settings_files = `git ls-files --other --ignored --exclude-from=.gitignore | sed -e "s|^|${PWD}/|" | grep --colour=never -E '#{::Chamber.filenames.join('|')}'`

        ::Chamber.load  files:       ignored_settings_files.split("\n"),
                        namespaces:  options[:namespaces]
      end

      if options[:dry_run]
        puts "Running without --dry-run will set the following Heroku environment variables"

        puts ::Chamber.to_s(pair_separator: "\n")
      else
        heroku("config:set #{::Chamber.to_s}")
      end
    end

    desc 'pull', 'Retrieves the environment variables for the application and stores them in a temporary file'
    method_option :into,
                  type:     :string,
                  desc:     'The file into which the Heroku config information should be stored. This file WILL BE OVERRIDDEN.'
    def pull
      current_heroku_config = heroku("config --shell")

      if options[:into]
        ::File.open(options[:into], 'w+') do |file|
          file.write current_heroku_config
        end
      else
        puts current_heroku_config
      end
    end

    desc 'diff', 'Displays the difference between what is currently stored in the Heroku application\'s config and what Chamber knows about locally'
    method_option :only_ignored,
                  type:     :boolean,
                  aliases:  '-o',
                  default:  true,
                  desc:     'When enabled, the diff will only consider settings contained in files which have been gitignored, the rest will be accessed directly'
    def diff
      ::Chamber::Commands::Chamber.init(options)

      if options[:only_ignored]
        ignored_settings_files = `git ls-files --other --ignored --exclude-from=.gitignore | sed -e "s|^|${PWD}/|" | grep --colour=never -E '#{::Chamber.filenames.join('|')}'`

        ::Chamber.load  files:       ignored_settings_files.split("\n"),
                        namespaces:  options[:namespaces]
      end

      current_heroku_config = heroku("config --shell")
      current_local_config  = ::Chamber.to_s(pair_separator:    "\n",
                                             value_surrounder:  '')

      heroku_config_file =  Tempfile.open('heroku') do |file|
                              file.write  current_heroku_config.chomp
                              file.to_path
                            end
      local_config_file  =  Tempfile.open('local') do |file|
                              file.write  current_local_config
                              file.to_path
                            end

      system("git diff --no-index #{local_config_file} #{heroku_config_file}")
    end

    no_commands do
      def app
        options[:app] ? " --app #{options[:app]}" : ""
      end

      def heroku(command)
        Bundler.with_clean_env { `heroku #{command}#{app}` }
      end
    end
  end

  class Travis < Thor
    desc 'secure', 'Uses your Travis CI public key to encrypt the settings you have chosen not to commit to the repo'
    method_option :dry_run,
                  type:     :boolean,
                  aliases:  '-d',
                  desc:     'Does not actually encrypt anything to .travis.yml, but instead displays what values would be encrypted'
    method_option :only_ignored,
                  type:     :boolean,
                  aliases:  '-o',
                  default:  true,
                  desc:     'Does not encrpyt settings into .travis.yml unless the file that the setting is contained in has been gitignored'
    def secure
      ::Chamber::Commands::Chamber.init(options)

      if options[:only_ignored]
        ignored_settings_files = `git ls-files --other --ignored --exclude-from=.gitignore | sed -e "s|^|${PWD}/|" | grep --colour=never -E '#{::Chamber.filenames.join('|')}'`

        ::Chamber.load  files:       ignored_settings_files.split("\n"),
                        namespaces:  options[:namespaces]
      end

      setting_values = ::Chamber.to_s(pair_separator: "\n")

      if options[:dry_run]
        puts "Running without --dry-run will encrypt the following Travis CI environment variables"

        puts setting_values
      else
        travis_encrypt('--override ryterutoiuewrtoiuweorit="invalid"')

        setting_values.each_line do |line|
          puts "Encrypting: #{line}"
          travis_encrypt("--append #{line}")
        end
      end
    end

    no_commands do
      def travis_encrypt(command)
        Bundler.with_clean_env { `travis encrypt --add 'env.global' #{command}` }
      end
    end
  end

  class Settings < Thor
    include Thor::Actions

    desc 'show', 'Displays the list of settings and their values'
    method_option :as_env,
                  type:     :boolean,
                  aliases:  '-e',
                  desc:     'Whether the displayed settings should be environment variable compatible'
    def show
      ::Chamber::Commands::Chamber.init(options)

      if options[:as_env]
        puts ::Chamber.to_s(pair_separator: "\n")
      else
        pp ::Chamber.to_hash
      end
    end

    desc 'files', 'Lists the settings files which are parsed with the given options'
    def files
      ::Chamber::Commands::Chamber.init(options)

      pp ::Chamber.filenames
    end

    desc 'compare', 'Displays the difference between what is currently stored in the Heroku application\'s config and what Chamber knows about locally'
    method_option :keys_only,
                  type:     :boolean,
                  default:  true,
                  desc:     'Whether or not to only compare the keys but not the values of the two sets of settings'
    method_option :first,
                  type:     :array,
                  desc:     'The list of namespaces which will be used as the source of the comparison'
    method_option :second,
                  type:     :array,
                  desc:     'The list of namespaces which will be used as the destination of the comparison'
    def compare
      ::Chamber::Commands::Chamber.init(options)

      ::Chamber.load  basepath:   options[:basepath],
                      files:      options[:files],
                      namespaces: options[:first]

      first_config  = if options[:keys_only]
                        ::Chamber.to_environment.keys.join("\n")
                      else
                        ::Chamber.to_s(pair_separator: "\n")
                      end

      ::Chamber.load  basepath:   options[:basepath],
                      files:      options[:files],
                      namespaces: options[:second]

      second_config = if options[:keys_only]
                        ::Chamber.to_environment.keys.join("\n")
                      else
                        ::Chamber.to_s(pair_separator: "\n")
                      end

      first_config_file   = Tempfile.open('first') do |file|
                              file.write  first_config
                              file.to_path
                            end
      second_config_file  = Tempfile.open('second') do |file|
                              file.write  second_config
                              file.to_path
                            end

      system("git diff --no-index #{first_config_file} #{second_config_file}")
    end

    desc 'secure', 'Secures any values which appear to need to be encrypted in any of the settings files which match irrespective of namespaces'
    def secure
      options[:namespaces] = ['*']

      ::Chamber::Commands::Chamber.init(options)

      ::Chamber.files.secure
    end

    desc 'init', 'Sets Chamber up matching best practices for secure configuration management'
    def init
      ::Chamber::Commands::Chamber.init(options)

      key = OpenSSL::PKey::RSA.new(2048)
      create_file "#{options[:rootpath]}/.chamber.pem",     key.to_pem
      create_file "#{options[:rootpath]}/.chamber.pub.pem", key.public_key.to_pem

      unless ::File.read('./.gitignore').match /^.chamber.pem$/
        append_to_file './.gitignore', '.chamber.pem'
      end

      create_file "#{options[:basepath]}/settings.yml", ''
    end
  end

  class Chamber < Thor
    class_option  :rootpath,
                  type:     :string,
                  default:  ENV['PWD'],
                  desc:     'The root filepath of the application'
    class_option  :basepath,
                  type:     :string,
                  aliases:  '-b',
                  desc:     'The base filepath where Chamber will look for the conventional settings files'
    class_option  :files,
                  type:     :array,
                  aliases:  '-f',
                  desc:     'The set of file globs that Chamber will use for processing'
    class_option  :namespaces,
                  type:     :array,
                  aliases:  '-n',
                  default:  [],
                  desc:     'The set of namespaces that Chamber will use for processing'
    class_option  :preset,
                  type:     :string,
                  aliases:  '-p',
                  enum:     ['rails'],
                  desc:     'Used to quickly assign a given scenario to the chamber command (eg Rails apps)'
    class_option  :decryption_key,
                  type:     :string,
                  desc:     'The path to or contents of the private key associated with the project (typically .chamber.pem)'
    class_option  :encryption_key,
                  type:     :string,
                  desc:     'The path to or contents of the public key associated with the project (typically .chamber.pub.pem)'

    desc 'settings SUBCOMMAND ...ARGS', 'For working with Chamber settings'
    subcommand 'settings',  ::Chamber::Commands::Settings

    desc 'travis SUBCOMMAND ...ARGS',   'For manipulating Travis CI environment variables'
    subcommand 'travis',    ::Chamber::Commands::Travis

    desc 'heroku SUBCOMMAND ...ARGS',   'For manipulating Heroku environment variables'
    subcommand 'heroku',    ::Chamber::Commands::Heroku

    no_commands do
      def self.init(options)
        if options[:preset] == 'rails'
          require ::File.expand_path('./config/application')

          options[:rootpath]       = Rails.root
          options[:basepath]       = Rails.root.join('config')
          options[:namespaces]     = options[:namespaces].empty? ? [Rails.env] : options[:namespaces]
          options[:encryption_key] = options[:encryption_key] ? options[:encryption_key] : Rails.root.join('.chamber.pub.pem')
          options[:decryption_key] = options[:decryption_key] ? options[:decryption_key] : Rails.root.join('.chamber.pem')
        end

        ::Chamber.load  basepath:       options[:basepath],
                        files:          options[:files],
                        namespaces:     options[:namespaces],
                        encryption_key: options[:encryption_key],
                        decryption_key: options[:decryption_key]
      end
    end
  end
end
end

Chamber::Commands::Chamber.start
